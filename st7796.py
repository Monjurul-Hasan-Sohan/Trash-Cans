import time
from machine import Pin, SPI
import struct

# ST7796 Command Constants
ST7796_SWRESET = 0x01
ST7796_SLPOUT  = 0x11
ST7796_DISPOFF = 0x28
ST7796_DISPON  = 0x29
ST7796_CASET   = 0x2A
ST7796_RASET   = 0x2B
ST7796_RAMWR   = 0x2C
ST7796_MADCTL  = 0x36
ST7796_COLMOD  = 0x3A

class ST7796:
    def __init__(self, spi, cs, dc, rst=None, bl=None, width=480, height=320, rotation=1):
        self.spi = spi
        self.cs = cs
        self.dc = dc
        self.rst = rst
        self.bl = bl
        self.width = width
        self.height = height
        
        self.cs.init(self.cs.OUT, value=1)
        self.dc.init(self.dc.OUT, value=0)
        
        if self.rst:
            self.rst.init(self.rst.OUT, value=1)
        if self.bl:
            self.bl.init(self.bl.OUT, value=1)
            
        self.reset()
        self.init_display()
        self.set_rotation(rotation)

    def reset(self):
        if self.rst:
            self.rst.value(0)
            time.sleep_ms(50)
            self.rst.value(1)
            time.sleep_ms(50)
        else:
            self.write_cmd(ST7796_SWRESET)
            time.sleep_ms(150)

    def write_cmd(self, cmd):
        self.dc.value(0)
        self.cs.value(0)
        self.spi.write(bytearray([cmd]))
        self.cs.value(1)

    def write_data(self, buf):
        self.dc.value(1)
        self.cs.value(0)
        self.spi.write(buf)
        self.cs.value(1)

    def init_display(self):
        self.write_cmd(ST7796_SWRESET)
        time.sleep_ms(120)
        self.write_cmd(ST7796_SLPOUT)
        time.sleep_ms(120)
        self.write_cmd(0xF0); self.write_data(b'\xC3')
        self.write_cmd(0xF0); self.write_data(b'\x96')
        self.write_cmd(ST7796_COLMOD); self.write_data(b'\x55') # 16-bit color
        self.write_cmd(0xB4); self.write_data(b'\x01')
        self.write_cmd(0xB6); self.write_data(b'\x80\x02\x3B') 
        self.write_cmd(0xE8); self.write_data(b'\x40\x8A\x00\x00\x29\x19\xA5\x33')
        self.write_cmd(0xC1); self.write_data(b'\x06')
        self.write_cmd(0xC2); self.write_data(b'\xA7')
        self.write_cmd(0xC5); self.write_data(b'\x18')
        self.write_cmd(ST7796_DISPON)
        time.sleep_ms(50)

    def set_window(self, x0, y0, x1, y1):
        self.write_cmd(ST7796_CASET)
        self.write_data(struct.pack(">HH", x0, x1))
        self.write_cmd(ST7796_RASET)
        self.write_data(struct.pack(">HH", y0, y1))
        self.write_cmd(ST7796_RAMWR)

    def fill(self, color):
        # Optimized fill using large buffer chunks
        hi = (color >> 8) & 0xFF
        lo = color & 0xFF
        buffer = bytearray([hi, lo] * 1024) # 2KB chunk
        self.set_window(0, 0, self.width - 1, self.height - 1)
        
        pixels = self.width * self.height
        chunk_pixels = 1024
        while pixels > 0:
            count = min(pixels, chunk_pixels)
            self.write_data(buffer[:count*2])
            pixels -= count

    def set_rotation(self, rotation):
        self.write_cmd(ST7796_MADCTL)
        if rotation == 0: val = 0x48
        elif rotation == 1: val = 0x28 # Landscape
        elif rotation == 2: val = 0x88
        elif rotation == 3: val = 0xE8
        else: val = 0x48
        self.write_data(bytearray([val]))

    def draw_char_fast(self, char, x, y, color, bg_color, size):
        # 5x8 Font Bitmap
        font = [
            0x00, 0x00, 0x00, 0x00, 0x00, # space
            0x00, 0x00, 0x5F, 0x00, 0x00, # !
            0x00, 0x03, 0x00, 0x03, 0x00, # "
            0x14, 0x3E, 0x14, 0x3E, 0x14, # #
            0x24, 0x2A, 0x7F, 0x2A, 0x12, # $
            0x23, 0x13, 0x08, 0x64, 0x62, # %
            0x36, 0x49, 0x55, 0x22, 0x50, # &
            0x00, 0x05, 0x03, 0x00, 0x00, # '
            0x00, 0x1C, 0x22, 0x41, 0x00, # (
            0x00, 0x41, 0x22, 0x1C, 0x00, # )
            0x14, 0x08, 0x3E, 0x08, 0x14, # *
            0x08, 0x08, 0x3E, 0x08, 0x08, # +
            0x00, 0x50, 0x30, 0x00, 0x00, # ,
            0x08, 0x08, 0x08, 0x08, 0x08, # -
            0x00, 0x60, 0x60, 0x00, 0x00, # .
            0x20, 0x10, 0x08, 0x04, 0x02, # /
            0x3E, 0x51, 0x49, 0x45, 0x3E, # 0
            0x00, 0x42, 0x7F, 0x40, 0x00, # 1
            0x42, 0x61, 0x51, 0x49, 0x46, # 2
            0x21, 0x41, 0x45, 0x4B, 0x31, # 3
            0x18, 0x14, 0x12, 0x7F, 0x10, # 4
            0x27, 0x45, 0x45, 0x45, 0x39, # 5
            0x3C, 0x4A, 0x49, 0x49, 0x30, # 6
            0x01, 0x71, 0x09, 0x05, 0x03, # 7
            0x36, 0x49, 0x49, 0x49, 0x36, # 8
            0x06, 0x49, 0x49, 0x29, 0x1E, # 9
            0x00, 0x36, 0x36, 0x00, 0x00, # :
            0x00, 0x56, 0x36, 0x00, 0x00, # ;
            0x08, 0x14, 0x22, 0x41, 0x00, # <
            0x14, 0x14, 0x14, 0x14, 0x14, # =
            0x00, 0x41, 0x22, 0x14, 0x08, # >
            0x02, 0x01, 0x51, 0x09, 0x06, # ?
            0x32, 0x49, 0x79, 0x41, 0x3E, # @
            0x7E, 0x11, 0x11, 0x11, 0x7E, # A
            0x7F, 0x49, 0x49, 0x49, 0x36, # B
            0x3E, 0x41, 0x41, 0x41, 0x22, # C
            0x7F, 0x41, 0x41, 0x22, 0x1C, # D
            0x7F, 0x49, 0x49, 0x49, 0x41, # E
            0x7F, 0x09, 0x09, 0x09, 0x01, # F
            0x3E, 0x41, 0x49, 0x49, 0x7A, # G
            0x7F, 0x08, 0x08, 0x08, 0x7F, # H
            0x00, 0x41, 0x7F, 0x41, 0x00, # I
            0x20, 0x40, 0x41, 0x3F, 0x01, # J
            0x7F, 0x08, 0x14, 0x22, 0x41, # K
            0x7F, 0x40, 0x40, 0x40, 0x40, # L
            0x7F, 0x02, 0x0C, 0x02, 0x7F, # M
            0x7F, 0x04, 0x08, 0x10, 0x7F, # N
            0x3E, 0x41, 0x41, 0x41, 0x3E, # O
            0x7F, 0x09, 0x09, 0x09, 0x06, # P
            0x3E, 0x41, 0x51, 0x21, 0x5E, # Q
            0x7F, 0x09, 0x19, 0x29, 0x46, # R
            0x46, 0x49, 0x49, 0x49, 0x31, # S
            0x01, 0x01, 0x7F, 0x01, 0x01, # T
            0x3F, 0x40, 0x40, 0x40, 0x3F, # U
            0x1F, 0x20, 0x40, 0x20, 0x1F, # V
            0x3F, 0x40, 0x38, 0x40, 0x3F, # W
            0x63, 0x14, 0x08, 0x14, 0x63, # X
            0x07, 0x08, 0x70, 0x08, 0x07, # Y
            0x61, 0x51, 0x49, 0x45, 0x43, # Z
            0x00, 0x7F, 0x41, 0x41, 0x00, # [
            0x02, 0x04, 0x08, 0x10, 0x20, # \
            0x00, 0x41, 0x41, 0x7F, 0x00, # ]
            0x04, 0x02, 0x01, 0x02, 0x04, # ^
            0x40, 0x40, 0x40, 0x40, 0x40, # _
            0x00, 0x01, 0x02, 0x04, 0x00, # `
            0x20, 0x54, 0x54, 0x54, 0x78, # a
            0x7F, 0x48, 0x44, 0x44, 0x38, # b
            0x38, 0x44, 0x44, 0x44, 0x20, # c
            0x38, 0x44, 0x44, 0x48, 0x7F, # d
            0x38, 0x54, 0x54, 0x54, 0x18, # e
            0x08, 0x7E, 0x09, 0x01, 0x02, # f
            0x0C, 0x52, 0x52, 0x52, 0x3E, # g
            0x7F, 0x08, 0x04, 0x04, 0x78, # h
            0x00, 0x44, 0x7D, 0x40, 0x00, # i
            0x20, 0x40, 0x44, 0x3D, 0x00, # j
            0x7F, 0x10, 0x28, 0x44, 0x00, # k
            0x00, 0x41, 0x7F, 0x40, 0x00, # l
            0x7C, 0x04, 0x18, 0x04, 0x78, # m
            0x7C, 0x08, 0x04, 0x04, 0x78, # n
            0x38, 0x44, 0x44, 0x44, 0x38, # o
            0x7C, 0x14, 0x14, 0x14, 0x08, # p
            0x08, 0x14, 0x14, 0x18, 0x7C, # q
            0x7C, 0x08, 0x04, 0x04, 0x08, # r
            0x48, 0x54, 0x54, 0x54, 0x20, # s
            0x04, 0x3F, 0x44, 0x40, 0x20, # t
            0x3C, 0x40, 0x40, 0x20, 0x7C, # u
            0x1C, 0x20, 0x40, 0x20, 0x1C, # v
            0x3C, 0x40, 0x30, 0x40, 0x3C, # w
            0x44, 0x28, 0x10, 0x28, 0x44, # x
            0x0C, 0x50, 0x50, 0x50, 0x3C, # y
            0x44, 0x64, 0x54, 0x4C, 0x44, # z
            0x00, 0x08, 0x36, 0x41, 0x00, # {
            0x00, 0x00, 0x7F, 0x00, 0x00, # |
            0x00, 0x41, 0x36, 0x08, 0x00, # }
            0x10, 0x08, 0x08, 0x10, 0x08, # ~
        ]
        
        # ASCII offset
        if ord(char) < 32 or ord(char) > 126: char = '?'
        idx = (ord(char) - 32) * 5
        char_data = font[idx:idx+5]
        
        # Buffer Logic: Create a single buffer for the entire scaled character
        w = 5 * size
        h = 8 * size
        
        color_hi, color_lo = (color >> 8) & 0xFF, color & 0xFF
        bg_hi, bg_lo = (bg_color >> 8) & 0xFF, bg_color & 0xFF
        
        buffer = bytearray([bg_hi, bg_lo] * (w * h))
        
        for col in range(5):
            line = char_data[col]
            for row in range(8):
                if (line >> row) & 0x01:
                    start_x = col * size
                    start_y = row * size
                    for sy in range(size):
                        for sx in range(size):
                            idx = ((start_y + sy) * w + (start_x + sx)) * 2
                            buffer[idx] = color_hi
                            buffer[idx+1] = color_lo
                            
        self.set_window(x, y, x + w - 1, y + h - 1)
        self.write_data(buffer)
        
        # Guard clause: ensure we never return None
        if x is None:
            return 0
        return x + (6 * size)

    def text(self, string, x, y, color, bg_color=0x0000, size=2):
        curr_x = x
        for char in string:
            curr_x = self.draw_char_fast(char, curr_x, y, color, bg_color, size)
        return curr_x